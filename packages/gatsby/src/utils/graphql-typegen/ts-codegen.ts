import * as fs from "fs-extra"
import { join } from "path"
import { codegen } from "@graphql-codegen/core"
import { Kind } from "graphql"
import type { Types } from "@graphql-codegen/plugin-helpers"
import type { TypeScriptPluginConfig } from "@graphql-codegen/typescript/config"
import type { TypeScriptDocumentsPluginConfig } from "@graphql-codegen/typescript-operations/config"
import { AnyAction, Store } from "redux"
import { CodeFileLoader } from "@graphql-tools/code-file-loader"
import { loadDocuments } from "@graphql-tools/load"
import { IGatsbyState, IStateProgram } from "../../redux/types"
import { filterTargetDefinitions, stabilizeSchema } from "./utils"

const OUTPUT_PATH = `src/gatsby-types.d.ts`
const NAMESPACE = `Queries`

// These override the defaults from
// https://www.graphql-code-generator.com/plugins/typescript
const DEFAULT_TYPESCRIPT_CONFIG: Readonly<TypeScriptPluginConfig> = {
  // <Maybe> Type is enough
  avoidOptionals: true,
  // Types come from the data layer so they can't be modified
  immutableTypes: true,
  // TODO: Better maybeValue
  maybeValue: `T | undefined`,
  // We'll want to re-export ourselves
  noExport: true,
  // Recommended for .d.ts files
  enumsAsTypes: true,
  scalars: {
    Date: `string`,
    JSON: `Record<string, unknown>`,
  },
  // import type {} syntax is nicer
  useTypeImports: true,
}

const DEFAULT_TYPESCRIPT_OPERATIONS_CONFIG: Readonly<TypeScriptDocumentsPluginConfig> =
  {
    ...DEFAULT_TYPESCRIPT_CONFIG,
    exportFragmentSpreadSubTypes: true,
  }

export async function writeTypeScriptTypes(
  directory: IStateProgram["directory"],
  store: Store<IGatsbyState, AnyAction>
): Promise<void> {
  const pluginConfig: Pick<Types.GenerateOptions, "plugins" | "pluginMap"> = {
    pluginMap: {
      add: require(`@graphql-codegen/add`),
      typescript: require(`@graphql-codegen/typescript`),
      typescriptOperations: require(`@graphql-codegen/typescript-operations`),
    },
    plugins: [
      {
        add: {
          placement: `prepend`,
          content: `/* eslint-disable */\n`,
        },
      },
      {
        add: {
          placement: `prepend`,
          content: `/* THIS FILE IS AUTOGENERATED. CHANGES WILL BE LOST ON SUBSEQUENT RUNS. */\n`,
        },
      },
      {
        add: {
          placement: `prepend`,
          content: `declare namespace ${NAMESPACE} {\n`,
        },
      },
      {
        typescript: DEFAULT_TYPESCRIPT_CONFIG,
      },
      {
        typescriptOperations: DEFAULT_TYPESCRIPT_OPERATIONS_CONFIG,
      },
      {
        add: {
          placement: `append`,
          content: `\n}\n`,
        },
      },
    ],
  }

  const { schema, definitions } = store.getState()
  const filename = join(directory, OUTPUT_PATH)

  let gatsbyNodeDocuments: Array<Types.DocumentFile> = []
  // The loadDocuments + CodeFileLoader looks for graphql(``) functions inside the gatsby-node.ts files
  // And then extracts the queries into documents
  // The behavior can be modified: https://www.graphql-tools.com/docs/graphql-tag-pluck
  try {
    gatsbyNodeDocuments = await loadDocuments(
      [`./gatsby-node.ts`, `./plugins/**/gatsby-node.ts`],
      {
        loaders: [new CodeFileLoader()],
      }
    )
  } catch (e) {
    // These files might not exist, so just skip this
  }

  const documents: Array<Types.DocumentFile> = [
    ...filterTargetDefinitions(definitions).values(),
  ].map(definitionMeta => {
    return {
      document: {
        kind: Kind.DOCUMENT,
        definitions: [definitionMeta.def],
      },
      hash: definitionMeta.hash.toString(),
    }
  })

  const isVerbose = process.env.gatsby_log_level === `verbose`

  const codegenOptions: Omit<Types.GenerateOptions, "plugins" | "pluginMap"> = {
    // @ts-ignore - Incorrect types
    schema: undefined,
    schemaAst: stabilizeSchema(schema),
    documents: documents.concat(gatsbyNodeDocuments),
    filename,
    config: {
      namingConvention: {
        typeNames: `keep`,
        enumValues: `keep`,
        transformUnderscore: false,
      },
      addUnderscoreToArgsType: true,
      skipTypename: true,
      flattenGeneratedTypes: true,
    },
    skipDocumentsValidation: !isVerbose,
  }

  const result = await codegen({
    ...pluginConfig,
    ...codegenOptions,
  })

  await fs.outputFile(filename, result)
}
