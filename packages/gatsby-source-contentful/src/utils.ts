import { ContentType, ContentTypeField } from "contentful"
import { MarkdownFieldDefinition } from "./types/plugin"
import { makeTypeName } from "./normalize"

// When iterating on tons of objects, we don't want to block the event loop
// this helper function returns a promise that resolves on the next tick so that the event loop can continue before we continue running blocking code
export function untilNextEventLoopTick(): Promise<null> {
  return new Promise(res => {
    setImmediate(() => {
      res(null)
    })
  })
}

export function detectMarkdownField(
  field: ContentTypeField,
  contentTypeItem: ContentType,
  enableMarkdownDetection: boolean,
  markdownFields: MarkdownFieldDefinition
): string {
  let typeName = field.type as string

  if (typeName == `Text` && enableMarkdownDetection) {
    typeName = `Markdown`
  }

  // Detect markdown based on given field ids
  const markdownFieldDefinitions = markdownFields.get(contentTypeItem.sys.id)
  if (markdownFieldDefinitions && markdownFieldDefinitions.includes(field.id)) {
    typeName = `Markdown`
  }

  return typeName
}

// Establish identifier for content type based on plugin options
//  Use `name` if specified, otherwise, use internal id (usually a natural-language constant,
//  but sometimes a base62 uuid generated by Contentful, hence the option)
export function makeContentTypeIdMap(
  contentTypeItems: Array<ContentType>,
  contentTypePrefix: string,
  useNameForId: boolean
): Map<string, string> {
  const contentTypeIdMap: Map<string, string> = new Map()

  contentTypeItems.forEach(contentType => {
    let contentTypeItemId
    if (useNameForId) {
      contentTypeItemId = makeTypeName(contentType.name, contentTypePrefix)
    } else {
      contentTypeItemId = makeTypeName(contentType.sys.id, contentTypePrefix)
    }
    contentTypeIdMap.set(contentType.sys.id, contentTypeItemId)
  })
  return contentTypeIdMap
}
